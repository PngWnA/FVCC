['/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv {\n\nstruct JasperInitializer {\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder() {\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder() {\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const {\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close() {\n    if (m_stream) {\n        jas_stream_close((jas_stream_t*)m_stream);\n        m_stream = 0;\n    }\n\n    if (m_image) {\n        jas_image_destroy((jas_image_t*)m_image);\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader() {\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen(m_filename.c_str(), "rb");\n    m_stream = stream;\n\n    if (stream) {\n        jas_image_t* image = jas_image_decode(stream, -1, 0);\n        m_image = image;\n        if (image) {\n            m_width = jas_image_width(image);\n            m_height = jas_image_height(image);\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts(image);\n            int depth = 0;\n            for (int i = 0; i < numcmpts; i++) {\n                int depth_i = jas_image_cmptprec(image, i);\n                depth = MAX(depth, depth_i);\n                if (jas_image_cmpttype(image, i) > 2) {\n                    continue;\n                }\n                cntcmpts++;\n            }\n\n            if (cntcmpts) {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if (!result) {\n        close();\n    }\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData(Mat& img) {\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if (stream && image) {\n        bool convert;\n        int colorspace;\n        if (color) {\n            convert = (jas_image_clrspc(image) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        } else {\n            convert = (jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if (convert) {\n            jas_cmprof_t* clrprof = jas_cmprof_createfromclrspc(colorspace);\n            if (clrprof) {\n                jas_image_t* _img = jas_image_chclrspc(image, clrprof, JAS_CMXFORM_INTENT_RELCLR);\n                if (_img) {\n                    jas_image_destroy(image);\n                    m_image = image = _img;\n                    result = true;\n                } else {\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                }\n                jas_cmprof_destroy(clrprof);\n            } else {\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n            }\n        } else {\n            result = true;\n        }\n\n        if (result) {\n            int ncmpts;\n            int cmptlut[3];\n            if (color) {\n                cmptlut[0] = jas_image_getcmptbytype(image, JAS_IMAGE_CT_RGB_B);\n                cmptlut[1] = jas_image_getcmptbytype(image, JAS_IMAGE_CT_RGB_G);\n                cmptlut[2] = jas_image_getcmptbytype(image, JAS_IMAGE_CT_RGB_R);\n                if (cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0) {\n                    result = false;\n                }\n                ncmpts = 3;\n            } else {\n                cmptlut[0] = jas_image_getcmptbytype(image, JAS_IMAGE_CT_GRAY_Y);\n                if (cmptlut[0] < 0) {\n                    result = false;\n                }\n                ncmpts = 1;\n            }\n\n            if (result) {\n                for (int i = 0; i < ncmpts; i++) {\n                    int maxval = 1 << jas_image_cmptprec(image, cmptlut[i]);\n                    int offset =  jas_image_cmptsgnd(image, cmptlut[i]) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry(image, cmptlut[i]);\n                    int ystep = jas_image_cmptvstep(image, cmptlut[i]);\n                    int xend = jas_image_cmptbrx(image, cmptlut[i]);\n                    int xstep = jas_image_cmpthstep(image, cmptlut[i]);\n\n                    jas_matrix_t* buffer = jas_matrix_create(yend / ystep, xend / xstep);\n                    if (buffer) {\n                        if (!jas_image_readcmpt(image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer)) {\n                            if (img.depth() == CV_8U) {\n                                result = readComponent8u(data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts);\n                            } else {\n                                result = readComponent16u(((unsigned short*)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts);\n                            }\n                            if (!result) {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy(buffer);\n                    }\n                }\n            }\n        } else {\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n");\n        }\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u(uchar* data, void* _buffer,\n                                     int step, int cmpt,\n                                     int maxval, int offset, int ncmpts) {\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx(image, cmpt);\n    int xend = jas_image_cmptbrx(image, cmpt);\n    int xstep = jas_image_cmpthstep(image, cmpt);\n    int xoffset = jas_image_tlx(image);\n    int ystart = jas_image_cmpttly(image, cmpt);\n    int yend = jas_image_cmptbry(image, cmpt);\n    int ystep = jas_image_cmptvstep(image, cmpt);\n    int yoffset = jas_image_tly(image);\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval / 256.) / std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for (y = 0; y < yend - ystart;) {\n        jas_seqent_t* pix_row = &jas_matrix_get(buffer, y / ystep, 0);\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if (xstep == 1) {\n            if (maxval == 256 && offset == 0)\n                for (x = 0; x < xend - xstart; x++) {\n                    int pix = pix_row[x];\n                    dst[x* ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for (x = 0; x < xend - xstart; x++) {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x* ncmpts] = CV_CAST_8U(pix);\n                }\n        } else if (xstep == 2 && offset == 0)\n            for (x = 0, j = 0; x < xend - xstart; x += 2, j++) {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x* ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for (x = 0, j = 0; x < xend - xstart; j++) {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for (x1 = x + xstep; x < x1; x++) {\n                    dst[x* ncmpts] = (uchar)pix;\n                }\n            }\n        y1 = y + ystep;\n        for (++y; y < y1; y++, dst += step)\n            for (x = 0; x < xend - xstart; x++) {\n                dst[x* ncmpts + step] = dst[x*ncmpts];\n            }\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u(unsigned short* data, void* _buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts) {\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx(image, cmpt);\n    int xend = jas_image_cmptbrx(image, cmpt);\n    int xstep = jas_image_cmpthstep(image, cmpt);\n    int xoffset = jas_image_tlx(image);\n    int ystart = jas_image_cmpttly(image, cmpt);\n    int yend = jas_image_cmptbry(image, cmpt);\n    int ystep = jas_image_cmptvstep(image, cmpt);\n    int yoffset = jas_image_tly(image);\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval / 65536.) / std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for (y = 0; y < yend - ystart;) {\n        jas_seqent_t* pix_row = &jas_matrix_get(buffer, y / ystep, 0);\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if (xstep == 1) {\n            if (maxval == 65536 && offset == 0)\n                for (x = 0; x < xend - xstart; x++) {\n                    int pix = pix_row[x];\n                    dst[x* ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for (x = 0; x < xend - xstart; x++) {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x* ncmpts] = CV_CAST_16U(pix);\n                }\n        } else if (xstep == 2 && offset == 0)\n            for (x = 0, j = 0; x < xend - xstart; x += 2, j++) {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x* ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for (x = 0, j = 0; x < xend - xstart; j++) {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for (x1 = x + xstep; x < x1; x++) {\n                    dst[x* ncmpts] = (ushort)pix;\n                }\n            }\n        y1 = y + ystep;\n        for (++y; y < y1; y++, dst += step)\n            for (x = 0; x < xend - xstart; x++) {\n                dst[x* ncmpts + step] = dst[x*ncmpts];\n            }\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder() {\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder() {\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const {\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported(int depth) const {\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write(const Mat& _img, const vector<int>&) {\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if (channels > 3 || channels < 1) {\n        return false;\n    }\n\n    jas_image_cmptparm_t component_info[3];\n    for (int i = 0; i < channels; i++) {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t* img = jas_image_create(channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB);\n    if (!img) {\n        return false;\n    }\n\n    if (channels == 1) {\n        jas_image_setcmpttype(img, 0, JAS_IMAGE_CT_GRAY_Y);\n    } else {\n        jas_image_setcmpttype(img, 0, JAS_IMAGE_CT_RGB_B);\n        jas_image_setcmpttype(img, 1, JAS_IMAGE_CT_RGB_G);\n        jas_image_setcmpttype(img, 2, JAS_IMAGE_CT_RGB_R);\n    }\n\n    bool result;\n    if (depth == 8) {\n        result = writeComponent8u(img, _img);\n    } else {\n        result = writeComponent16u(img, _img);\n    }\n    if (result) {\n        jas_stream_t* stream = jas_stream_fopen(m_filename.c_str(), "wb");\n        if (stream) {\n            result = !jas_image_encode(img, stream, jas_image_strtofmt((char*)"jp2"), (char*)"");\n\n            jas_stream_close(stream);\n        }\n\n    }\n    jas_image_destroy(img);\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u(void* __img, const Mat& _img) {\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t* row = jas_matrix_create(1, w);\n    if (!row) {\n        return false;\n    }\n\n    for (int y = 0; y < h; y++) {\n        uchar* data = _img.data + _img.step * y;\n        for (int i = 0; i < ncmpts; i++) {\n            for (int x = 0; x < w; x++) {\n                jas_matrix_setv(row, x, data[x * ncmpts + i]);\n            }\n            jas_image_writecmpt(img, i, 0, y, w, 1, row);\n        }\n    }\n\n    jas_matrix_destroy(row);\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u(void* __img, const Mat& _img) {\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t* row = jas_matrix_create(1, w);\n    if (!row) {\n        return false;\n    }\n\n    for (int y = 0; y < h; y++) {\n        uchar* data = _img.data + _img.step * y;\n        for (int i = 0; i < ncmpts; i++) {\n            for (int x = 0; x < w; x++) {\n                jas_matrix_setv(row, x, data[x * ncmpts + i]);\n            }\n            jas_image_writecmpt(img, i, 0, y, w, 1, row);\n        }\n    }\n\n    jas_matrix_destroy(row);\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "_highgui.h"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.h"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "_highgui.h"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.h"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + string() + \'\\0\' + string() + \'\\0\' + string("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return new Jpeg2KDecoder;\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY?\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_8U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_8U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_8U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = CV_CAST_16U(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = CV_CAST_16U(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = CV_CAST_16U(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return new Jpeg2KEncoder;\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        uchar* data = _img.data + _img.step*y;\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n#include "opencv2/imgproc.hpp"\n\n#ifdef WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + String() + \'\\0\' + String() + \'\\0\' + String("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return makePtr<Jpeg2KDecoder>();\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    int step = (int)img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n#ifndef WIN32\n    // At least on some Linux instances the\n    // system libjasper segfaults when\n    // converting color to grey.\n    // We do this conversion manually at the end.\n    Mat clr;\n    if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type()))\n    {\n        clr.create(img.size().height, img.size().width, this->type());\n        color = true;\n        data = clr.ptr();\n        step = (int)clr.step;\n    }\n#endif\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY? (GENGRAY fails on Win.)\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n#ifndef WIN32\n    if (!clr.empty())\n    {\n        cv::cvtColor(clr, img, COLOR_BGR2GRAY);\n    }\n#endif\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = cv::saturate_cast<uchar>(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = cv::saturate_cast<uchar>(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = cv::saturate_cast<uchar>(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = cv::saturate_cast<uchar>(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = cv::saturate_cast<ushort>(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = cv::saturate_cast<ushort>(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = cv::saturate_cast<ushort>(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = cv::saturate_cast<ushort>(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return makePtr<Jpeg2KEncoder>();\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const std::vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        const uchar* data = _img.ptr(y);\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        const ushort* data = _img.ptr<ushort>(y);\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n', '/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution\'s of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution\'s in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors "as is" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include "precomp.hpp"\n\n#ifdef HAVE_JASPER\n\n#include "grfmt_jpeg2000.hpp"\n#include "opencv2/imgproc.hpp"\n\n#ifdef _WIN32\n#define JAS_WIN_MSVC_BUILD 1\n#ifdef __GNUC__\n#define HAVE_STDINT_H 1\n#endif\n#endif\n\n#undef VERSION\n\n#include <jasper/jasper.h>\n// FIXME bad hack\n#undef uchar\n#undef ulong\n\nnamespace cv\n{\n\nstruct JasperInitializer\n{\n    JasperInitializer() { jas_init(); }\n    ~JasperInitializer() { jas_cleanup(); }\n};\n\nstatic JasperInitializer initialize_jasper;\n\n\n/////////////////////// Jpeg2KDecoder ///////////////////\n\nJpeg2KDecoder::Jpeg2KDecoder()\n{\n    m_signature = \'\\0\' + String() + \'\\0\' + String() + \'\\0\' + String("\\x0cjP  \\r\\n\\x87\\n");\n    m_stream = 0;\n    m_image = 0;\n}\n\n\nJpeg2KDecoder::~Jpeg2KDecoder()\n{\n}\n\nImageDecoder Jpeg2KDecoder::newDecoder() const\n{\n    return makePtr<Jpeg2KDecoder>();\n}\n\nvoid  Jpeg2KDecoder::close()\n{\n    if( m_stream )\n    {\n        jas_stream_close( (jas_stream_t*)m_stream );\n        m_stream = 0;\n    }\n\n    if( m_image )\n    {\n        jas_image_destroy( (jas_image_t*)m_image );\n        m_image = 0;\n    }\n}\n\n\nbool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), "rb" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    size_t step = img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n#ifndef _WIN32\n    // At least on some Linux instances the\n    // system libjasper segfaults when\n    // converting color to grey.\n    // We do this conversion manually at the end.\n    Mat clr;\n    if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type()))\n    {\n        clr.create(img.size().height, img.size().width, this->type());\n        color = true;\n        data = clr.ptr();\n        step = (int)clr.step;\n    }\n#endif\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY? (GENGRAY fails on Win.)\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, "JPEG 2000 LOADER ERROR: cannot convert colorspace\\n");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, "JPEG 2000 LOADER ERROR: unable to create colorspace\\n");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, validateToInt(step), cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, "JPEG2000 LOADER ERROR: colorspace conversion failed\\n" );\n    }\n\n    close();\n\n#ifndef _WIN32\n    if (!clr.empty())\n    {\n        cv::cvtColor(clr, img, COLOR_BGR2GRAY);\n    }\n#endif\n\n    return result;\n}\n\n\nbool  Jpeg2KDecoder::readComponent8u( uchar *data, void *_buffer,\n                                      int step, int cmpt,\n                                      int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/256.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        uchar* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 256 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = cv::saturate_cast<uchar>(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = cv::saturate_cast<uchar>(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = cv::saturate_cast<uchar>(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = cv::saturate_cast<uchar>(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (uchar)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\nbool  Jpeg2KDecoder::readComponent16u( unsigned short *data, void *_buffer,\n                                       int step, int cmpt,\n                                       int maxval, int offset, int ncmpts )\n{\n    jas_matrix_t* buffer = (jas_matrix_t*)_buffer;\n    jas_image_t* image = (jas_image_t*)m_image;\n    int xstart = jas_image_cmpttlx( image, cmpt );\n    int xend = jas_image_cmptbrx( image, cmpt );\n    int xstep = jas_image_cmpthstep( image, cmpt );\n    int xoffset = jas_image_tlx( image );\n    int ystart = jas_image_cmpttly( image, cmpt );\n    int yend = jas_image_cmptbry( image, cmpt );\n    int ystep = jas_image_cmptvstep( image, cmpt );\n    int yoffset = jas_image_tly( image );\n    int x, y, x1, y1, j;\n    int rshift = cvRound(std::log(maxval/65536.)/std::log(2.));\n    int lshift = MAX(0, -rshift);\n    rshift = MAX(0, rshift);\n    int delta = (rshift > 0 ? 1 << (rshift - 1) : 0) + offset;\n\n    for( y = 0; y < yend - ystart; )\n    {\n        jas_seqent_t* pix_row = &jas_matrix_get( buffer, y / ystep, 0 );\n        ushort* dst = data + (y - yoffset) * step - xoffset;\n\n        if( xstep == 1 )\n        {\n            if( maxval == 65536 && offset == 0 )\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = pix_row[x];\n                    dst[x*ncmpts] = cv::saturate_cast<ushort>(pix);\n                }\n            else\n                for( x = 0; x < xend - xstart; x++ )\n                {\n                    int pix = ((pix_row[x] + delta) >> rshift) << lshift;\n                    dst[x*ncmpts] = cv::saturate_cast<ushort>(pix);\n                }\n        }\n        else if( xstep == 2 && offset == 0 )\n            for( x = 0, j = 0; x < xend - xstart; x += 2, j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                dst[x*ncmpts] = dst[(x+1)*ncmpts] = cv::saturate_cast<ushort>(pix);\n            }\n        else\n            for( x = 0, j = 0; x < xend - xstart; j++ )\n            {\n                int pix = ((pix_row[j] + delta) >> rshift) << lshift;\n                pix = cv::saturate_cast<ushort>(pix);\n                for( x1 = x + xstep; x < x1; x++ )\n                    dst[x*ncmpts] = (ushort)pix;\n            }\n        y1 = y + ystep;\n        for( ++y; y < y1; y++, dst += step )\n            for( x = 0; x < xend - xstart; x++ )\n                dst[x*ncmpts + step] = dst[x*ncmpts];\n    }\n\n    return true;\n}\n\n\n/////////////////////// Jpeg2KEncoder ///////////////////\n\n\nJpeg2KEncoder::Jpeg2KEncoder()\n{\n    m_description = "JPEG-2000 files (*.jp2)";\n}\n\n\nJpeg2KEncoder::~Jpeg2KEncoder()\n{\n}\n\nImageEncoder Jpeg2KEncoder::newEncoder() const\n{\n    return makePtr<Jpeg2KEncoder>();\n}\n\nbool  Jpeg2KEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\n\nbool  Jpeg2KEncoder::write( const Mat& _img, const std::vector<int>& )\n{\n    int width = _img.cols, height = _img.rows;\n    int depth = _img.depth(), channels = _img.channels();\n    depth = depth == CV_8U ? 8 : 16;\n\n    if( channels > 3 || channels < 1 )\n        return false;\n\n    jas_image_cmptparm_t component_info[3];\n    for( int i = 0; i < channels; i++ )\n    {\n        component_info[i].tlx = 0;\n        component_info[i].tly = 0;\n        component_info[i].hstep = 1;\n        component_info[i].vstep = 1;\n        component_info[i].width = width;\n        component_info[i].height = height;\n        component_info[i].prec = depth;\n        component_info[i].sgnd = 0;\n    }\n    jas_image_t *img = jas_image_create( channels, component_info, (channels == 1) ? JAS_CLRSPC_SGRAY : JAS_CLRSPC_SRGB );\n    if( !img )\n        return false;\n\n    if(channels == 1)\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_GRAY_Y );\n    else\n    {\n        jas_image_setcmpttype( img, 0, JAS_IMAGE_CT_RGB_B );\n        jas_image_setcmpttype( img, 1, JAS_IMAGE_CT_RGB_G );\n        jas_image_setcmpttype( img, 2, JAS_IMAGE_CT_RGB_R );\n    }\n\n    bool result;\n    if( depth == 8 )\n        result = writeComponent8u( img, _img );\n    else\n        result = writeComponent16u( img, _img );\n    if( result )\n    {\n        jas_stream_t *stream = jas_stream_fopen( m_filename.c_str(), "wb" );\n        if( stream )\n        {\n            result = !jas_image_encode( img, stream, jas_image_strtofmt( (char*)"jp2" ), (char*)"" );\n\n            jas_stream_close( stream );\n        }\n\n    }\n    jas_image_destroy( img );\n\n    return result;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent8u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        const uchar* data = _img.ptr(y);\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n    return true;\n}\n\n\nbool  Jpeg2KEncoder::writeComponent16u( void *__img, const Mat& _img )\n{\n    jas_image_t* img = (jas_image_t*)__img;\n    int w = _img.cols, h = _img.rows, ncmpts = _img.channels();\n    jas_matrix_t *row = jas_matrix_create( 1, w );\n    if(!row)\n        return false;\n\n    for( int y = 0; y < h; y++ )\n    {\n        const ushort* data = _img.ptr<ushort>(y);\n        for( int i = 0; i < ncmpts; i++ )\n        {\n            for( int x = 0; x < w; x++)\n                jas_matrix_setv( row, x, data[x * ncmpts + i] );\n            jas_image_writecmpt( img, i, 0, y, w, 1, row );\n        }\n    }\n\n    jas_matrix_destroy( row );\n\n    return true;\n}\n\n}\n\n#endif\n\n/* End of file. */\n']